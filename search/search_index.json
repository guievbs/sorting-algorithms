{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Apresenta\u00e7\u00e3o do Projeto","text":""},{"location":"#apresentacao-do-projeto","title":"Apresenta\u00e7\u00e3o do Projeto","text":""},{"location":"#objetivo-do-projeto","title":"\ud83c\udfaf Objetivo do Projeto","text":"<p>Apresentar, de forma clara e did\u00e1tica, os principais algoritmos de ordena\u00e7\u00e3o utilizados em Ci\u00eancia da Computa\u00e7\u00e3o. O material inclui:</p> <ul> <li>Explica\u00e7\u00f5es te\u00f3ricas detalhadas.</li> <li>Implementa\u00e7\u00f5es pr\u00e1ticas em Python e C.</li> <li>Recursos complementares, como v\u00eddeo-aulas.</li> </ul> <p>Este projeto segue a filosofia de Recursos Educacionais Abertos (REA), promovendo aprendizado acess\u00edvel e de alta qualidade.</p>"},{"location":"#escopo-algoritmos-de-ordenacao","title":"\ud83d\udd0d Escopo: Algoritmos de Ordena\u00e7\u00e3o","text":"<p>A apresenta\u00e7\u00e3o dos algoritmos ser\u00e1 organizada do mais simples ao mais complexo, destacando l\u00f3gica, exemplos pr\u00e1ticos e an\u00e1lises de desempenho.</p>"},{"location":"#algoritmos-apresentados","title":"Algoritmos Apresentados","text":"<ol> <li>Bubble Sort    Algoritmo mais simples e introdut\u00f3rio.</li> <li>Insertion Sort    Outra abordagem b\u00e1sica, eficiente para listas pequenas.</li> <li>Counting Sort    Algoritmo eficiente para entradas espec\u00edficas.</li> <li>Heap Sort    Explora a estrutura de heap para ordena\u00e7\u00e3o eficiente.</li> <li>Quick Sort    Famoso pela sua abordagem de divis\u00e3o e conquista.</li> <li>Merge Sort    Complexo e poderoso, ideal para grandes entradas.</li> </ol>"},{"location":"#conteudo-disponibilizado","title":"\ud83d\udcda Conte\u00fado Disponibilizado","text":""},{"location":"#1-explicacoes-teoricas","title":"1. Explica\u00e7\u00f5es Te\u00f3ricas","text":"<ul> <li>Detalhes sobre o funcionamento de cada algoritmo.</li> <li>An\u00e1lise de complexidade de tempo e espa\u00e7o.</li> <li>Casos de uso e desempenho (pior, melhor e caso m\u00e9dio).</li> </ul>"},{"location":"#2-implementacoes","title":"2. Implementa\u00e7\u00f5es","text":"<ul> <li>C\u00f3digo-fonte em Python e C.</li> <li>Exemplos pr\u00e1ticos comentados para facilitar o entendimento.</li> </ul>"},{"location":"#3-recursos-audiovisuais","title":"3. Recursos Audiovisuais","text":"<ul> <li>V\u00eddeo-aulas curtas explicando:</li> <li>Funcionamento.</li> <li>Implementa\u00e7\u00e3o pr\u00e1tica de cada algoritmo.</li> <li>Links para v\u00eddeos incorporados diretamente na p\u00e1gina.</li> </ul>"},{"location":"#publicacao-e-documentacao","title":"\ud83c\udf10 Publica\u00e7\u00e3o e Documenta\u00e7\u00e3o","text":"<p>Toda a documenta\u00e7\u00e3o e os c\u00f3digos estar\u00e3o organizados e dispon\u00edveis no GitHub Pages para facilitar a navega\u00e7\u00e3o e o aprendizado.</p>"},{"location":"#tecnologias-e-ferramentas-utilizadas","title":"\ud83e\uddf0 Tecnologias e Ferramentas Utilizadas","text":"<ul> <li>Linguagens: Python e C.</li> <li>Controle de Vers\u00e3o e Publica\u00e7\u00e3o: GitHub e GitHub Pages.</li> <li>Gest\u00e3o de Tarefas: Trello</li> <li>Recursos Audiovisuais: V\u00eddeos integrados na plataforma.</li> </ul>"},{"location":"#contribuidores","title":"\ud83e\udd20 Contribuidores","text":"<ul> <li>Guilherme Sebasti\u00e3o</li> <li>Matheus Marinho</li> <li>Gabriel Floriano</li> <li>Robson Carvalho</li> </ul> <p>Acompanhe o progresso e contribua no reposit\u00f3rio oficial: \ud83d\udd17 Acesse o reposit\u00f3rio no GitHub</p>"},{"location":"big_o/","title":"Nota\u00e7\u00e3o Big(O)","text":""},{"location":"big_o/#notacao-bigo","title":"Nota\u00e7\u00e3o Big(O)","text":"<p>A nota\u00e7\u00e3o Big O \u00e9 uma ferramenta matem\u00e1tica amplamente utilizada em ci\u00eancia da computa\u00e7\u00e3o para descrever a complexidade de algoritmos, especialmente em rela\u00e7\u00e3o ao tempo de execu\u00e7\u00e3o e ao uso de espa\u00e7o de mem\u00f3ria. Ela fornece uma maneira de classificar algoritmos com base em como seu desempenho se comporta \u00e0 medida que o tamanho da entrada aumenta.</p>"},{"location":"big_o/#definicao-e-importancia","title":"Defini\u00e7\u00e3o e Import\u00e2ncia","text":"<p>A nota\u00e7\u00e3o Big O \u00e9 usada para expressar o limite superior do tempo ou espa\u00e7o que um algoritmo pode consumir, considerando o pior caso poss\u00edvel. Em termos mais simples, ela nos ajuda a entender como um algoritmo se comportar\u00e1 \u00e0 medida que o volume de dados de entrada cresce. A nota\u00e7\u00e3o \u00e9 expressa como O(f(n)), onde f(n) \u00e9 uma fun\u00e7\u00e3o que representa o tempo ou espa\u00e7o necess\u00e1rio em rela\u00e7\u00e3o ao tamanho da entrada n.</p> <p>Por exemplo:</p> <ul> <li>O(1): Tempo constante</li> <li>O(n): Tempo linear</li> <li>O(n\u00b2): Tempo quadr\u00e1tico</li> <li>O(\\log n): Tempo logar\u00edtmico</li> </ul> <p>Essas classifica\u00e7\u00f5es s\u00e3o cruciais para comparar a efici\u00eancia de diferentes algoritmos e escolher a melhor solu\u00e7\u00e3o para um problema espec\u00edfico.</p>"},{"location":"big_o/#exemplos-comuns-de-notacao-bigo","title":"Exemplos Comuns de Nota\u00e7\u00e3o Big(O)","text":"<p>Aqui est\u00e3o algumas das nota\u00e7\u00f5es Big O mais comuns e suas interpreta\u00e7\u00f5es:</p> <ul> <li>O(1): A complexidade n\u00e3o depende do tamanho da entrada (tempo constante).</li> <li>O(n): A complexidade cresce linearmente com o tamanho da entrada.</li> <li>O(n\u00b2): A complexidade cresce quadraticamente, comum em algoritmos que usam loops aninhados.</li> <li>O(\\log n): A complexidade cresce logaritmicamente, t\u00edpico em algoritmos de busca bin\u00e1ria.</li> </ul> <p>A ordem de crescimento das fun\u00e7\u00f5es \u00e9 importante para entender a escalabilidade dos algoritmos. Por exemplo, um algoritmo com complexidade O(1) \u00e9 geralmente preferido a um com complexidade O(n\u00b2), especialmente quando lidamos com grandes volumes de dados.</p>"},{"location":"big_o/#conclusao","title":"Conclus\u00e3o","text":"<p>A nota\u00e7\u00e3o Big O \u00e9 fundamental na an\u00e1lise de algoritmos, permitindo que programadores e cientistas da computa\u00e7\u00e3o comparem a efici\u00eancia e escalabilidade das solu\u00e7\u00f5es propostas. Ela n\u00e3o fornece uma medida exata do tempo em segundos, mas sim uma maneira de entender como o desempenho do algoritmo muda \u00e0 medida que a entrada aumenta.</p>"},{"location":"big_o/#referencias","title":"Refer\u00eancias","text":"<p>Cita\u00e7\u00e3o:</p> <ul> <li>Boson Treinamentos</li> <li>Geeks for Geeks</li> <li>Dev.to</li> <li>Wikipedia</li> <li>Free Code Camp</li> <li>Brilliant</li> <li>Dev.to</li> <li>Toniesteves</li> </ul>"},{"location":"bubble_sort/","title":"Bubble Sort","text":""},{"location":"bubble_sort/#bubble-sort","title":"Bubble Sort","text":""},{"location":"bubble_sort/#introducao","title":"\ud83e\udee7 Introdu\u00e7\u00e3o","text":"<p>O Bubble Sort \u00e9 um algoritmo de ordena\u00e7\u00e3o simples, mas did\u00e1tico, amplamente utilizado para ensinar os fundamentos de algoritmos de ordena\u00e7\u00e3o. Apesar de sua performance inferior a outros algoritmos mais modernos, ele \u00e9 importante por ilustrar conceitos b\u00e1sicos como compar\u00e7\u00e3o e troca de elementos.</p>"},{"location":"bubble_sort/#curiosidade-o-nome-bubble-bolha-vem-da-ideia-de-que-os-elementos-maiores-flutuam-para-o-topo-da-lista-como-bolhas-na-agua","title":"Curiosidade: O nome \"Bubble\" (bolha) vem da ideia de que os elementos maiores \"flutuam\" para o topo da lista, como bolhas na \u00e1gua.","text":""},{"location":"bubble_sort/#motivacao-do-uso-e-desenvolvimento","title":"Motiva\u00e7\u00e3o do Uso e Desenvolvimento","text":"<p>O Bubble Sort foi desenvolvido como um algoritmo simples para ordena\u00e7\u00e3o, com a vantagem de ter uma implementa\u00e7\u00e3o intuitiva e clara. Apesar de n\u00e3o ser eficiente para conjuntos de dados grandes, ele \u00e9 frequentemente usado em aplica\u00e7\u00f5es did\u00e1ticas e em casos onde a simplicidade da implementa\u00e7\u00e3o \u00e9 mais importante que a efici\u00eancia.</p>"},{"location":"bubble_sort/#funcionamento-do-algoritmo","title":"Funcionamento do Algoritmo","text":""},{"location":"bubble_sort/#passo-a-passo","title":"Passo a Passo","text":"<ol> <li>Comparar pares consecutivos: Percorra a lista e compare cada par de elementos adjacentes.</li> <li>Trocar se necess\u00e1rio: Caso o elemento atual seja maior que o seguinte, troque-os de posi\u00e7\u00e3o.</li> <li>Repetir: Repita o processo at\u00e9 que nenhum elemento precise mais ser trocado, indicando que a lista est\u00e1 ordenada.</li> </ol> <p>Exemplo de Funcionamento:</p> <p>Lista original: <code>[5, 3, 8, 6]</code></p> <ul> <li>Passo 1: Compare o primeiro par <code>(5, 3)</code> e, como <code>5 &gt; 3</code>, realizamos a troca. A lista torna-se <code>[3, 5, 8, 6]</code>.</li> <li>Passo 2: Compare o pr\u00f3ximo par <code>(5, 8)</code>. Como <code>5 &lt; 8</code>, nenhuma troca \u00e9 feita.</li> <li>Passo 3: Compare o \u00faltimo par <code>(8, 6)</code> e, como <code>8 &gt; 6</code>, realizamos a troca. A lista torna-se <code>[3, 5, 6, 8]</code>.</li> <li>Passo 4: Na segunda varredura, nenhuma troca \u00e9 necess\u00e1ria, indicando que a lista j\u00e1 est\u00e1 ordenada. Resultado final: <code>[3, 5, 6, 8]</code>.</li> </ul>"},{"location":"bubble_sort/#complexidade","title":"\ud83d\udcca Complexidade","text":"<ul> <li>Melhor Caso: O(n) \u2013 quando a lista j\u00e1 est\u00e1 ordenada.</li> <li>Pior Caso: O(n\u00b2) \u2013 quando a lista est\u00e1 completamente desordenada.</li> <li>Caso M\u00e9dio: O(n\u00b2).</li> </ul> <p>O Bubble Sort n\u00e3o utiliza mem\u00f3ria adicional significativa, pois \u00e9 implementado in-place.</p>"},{"location":"bubble_sort/#implementacao","title":"\ud83d\udcbb Implementa\u00e7\u00e3o","text":""},{"location":"bubble_sort/#python","title":"Python","text":"<pre><code>def bubble_sort(array):\n    n = len(array)\n    for i in range(n):\n        trocou = False\n        for j in range(n - i - 1):\n            if array[j] &gt; array[j + 1]:\n                array[j], array[j + 1] = array[j + 1], array[j]\n                trocou = True\n        if not trocou:\n            break\n    return array\n</code></pre>"},{"location":"bubble_sort/#c","title":"C","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid bubbleSort(int arr[], int n) {\n    int trocou;\n    for (int i = 0; i &lt; n - 1; i++) {\n        trocou = 0;\n        for (int j = 0; j &lt; n - i - 1; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n                trocou = 1;\n            }\n        }\n        if (!trocou)\n            break;\n    }\n}\n</code></pre>"},{"location":"bubble_sort/#casos-de-uso","title":"\ud83d\udd27 Casos de Uso","text":"<ul> <li>Aplicativos onde a simplicidade \u00e9 mais importante que a efici\u00eancia.</li> <li>Cen\u00e1rios educacionais para ensinar algoritmos de ordena\u00e7\u00e3o.</li> <li>Pequenos conjuntos de dados que precisam ser ordenados rapidamente sem depend\u00eancia de bibliotecas externas.</li> </ul>"},{"location":"bubble_sort/#vantagens-e-desvantagens","title":"\u2696\ufe0f Vantagens e Desvantagens","text":""},{"location":"bubble_sort/#vantagens","title":"\u2705 Vantagens","text":"<ul> <li>Simples de entender e implementar.</li> <li>Pode ser otimizado para interromper quando a lista est\u00e1 ordenada (melhor caso).</li> <li>N\u00e3o requer mem\u00f3ria adicional.</li> </ul>"},{"location":"bubble_sort/#desvantagens","title":"\u274c Desvantagens","text":"<ul> <li>Ineficiente para grandes conjuntos de dados.</li> <li>Alto n\u00famero de compara\u00e7\u00f5es e trocas.</li> </ul>"},{"location":"bubble_sort/#curiosidades","title":"Curiosidades","text":"<ul> <li>Apesar de sua inefici\u00eancia, o Bubble Sort ainda \u00e9 usado em situa\u00e7\u00f5es muito espec\u00edficas, como microcontroladores simples.</li> <li>Ele \u00e9 frequentemente o primeiro algoritmo de ordena\u00e7\u00e3o que programadores aprendem.</li> </ul>"},{"location":"bubble_sort/#grafico-comparativo-com-outros-algoritmos","title":"Gr\u00e1fico Comparativo com Outros Algoritmos","text":"Algoritmo Melhor Caso Pior Caso Caso M\u00e9dio Bubble Sort O(n) O(n\u00b2) O(n\u00b2) Quick Sort O(n \\log n) O(n\u00b2) O(n \\log n) Merge Sort O(n \\log n) O(n \\log n) O(n \\log n) Insertion Sort O(n) O(n\u00b2) O(n\u00b2)"},{"location":"bubble_sort/#como-o-bubble-sort-se-comporta-em-listas-com-elementos-repetidos","title":"Como o Bubble Sort se comporta em listas com elementos repetidos","text":"<p>O Bubble Sort \u00e9 est\u00e1vel, o que significa que ele preserva a ordem relativa de elementos iguais na lista final.</p>"},{"location":"bubble_sort/#importancia-dos-algoritmos-de-ordenacao","title":"Import\u00e2ncia dos Algoritmos de Ordena\u00e7\u00e3o","text":"<p>Os algoritmos de ordena\u00e7\u00e3o s\u00e3o fundamentais na computa\u00e7\u00e3o por:</p> <ul> <li>Melhorar a efici\u00eancia de buscas.</li> <li>Organizar dados para an\u00e1lise posterior.</li> <li>Facilitar outras opera\u00e7\u00f5es algoritmicas, como jun\u00e7\u00f5es e filtros em bases de dados.</li> </ul>"},{"location":"bubble_sort/#programacao-competitiva","title":"Programa\u00e7\u00e3o Competitiva","text":"<p>Na programa\u00e7\u00e3o competitiva, o Bubble Sort n\u00e3o \u00e9 amplamente utilizado devido \u00e0 sua lentid\u00e3o. Contudo, \u00e9 frequentemente usado como um ponto de partida para entender outros algoritmos de ordena\u00e7\u00e3o mais eficientes.</p>"},{"location":"bubble_sort/#quiz-interativo","title":"Quiz Interativo","text":"<ol> <li>Qual \u00e9 a complexidade do Bubble Sort no melhor caso?</li> <li>O Bubble Sort \u00e9 um algoritmo:</li> <li>Em que cen\u00e1rio o Bubble Sort \u00e9 ideal?</li> </ol>"},{"location":"bubble_sort/#recursos-graficos-na-web","title":"Recursos Gr\u00e1ficos na Web","text":"<ul> <li>Visualgo</li> <li>GeeksforGeeks</li> </ul>"},{"location":"bubble_sort/#dicas-para-programar-no-leetcode","title":"Dicas para Programar no LeetCode","text":"<ol> <li>Entenda bem o problema antes de implementar a solu\u00e7\u00e3o.</li> <li>Experimente otimiza\u00e7\u00f5es simples, como parar a itera\u00e7\u00e3o cedo quando a lista j\u00e1 estiver ordenada.</li> <li>Compreenda bem as limita\u00e7\u00f5es do algoritmo para evitar aplic\u00e1-lo em casos inadequados.</li> </ol>"},{"location":"bubble_sort/#video-explicativo","title":"\ud83c\udfa5 V\u00eddeo Explicativo","text":""},{"location":"bubble_sort/#link-do-video","title":"Link do v\u00eddeo","text":""},{"location":"bubble_sort/#referencias","title":"Refer\u00eancias","text":"<p>Esses detalhes adicionais enriquecem a documenta\u00e7\u00e3o do Bubble Sort e ajudam a compreender melhor sua import\u00e2ncia na ci\u00eancia da computa\u00e7\u00e3o.</p> <p>Cita\u00e7\u00e3o:</p> <ol> <li>Trybe Blog - Bubble Sort</li> <li>Embarcados - Bubble Sort</li> <li>Prof. Desiqqueira - Bubble Sort</li> <li>ElemarJR - Bubble Sort</li> <li>IFRN - Bubble Sort</li> <li>FreeCodeCamp - Algoritmos de Ordena\u00e7\u00e3o</li> <li>Wikipedia - Bubble Sort</li> <li>UFG - M\u00e9todos de Ordena\u00e7\u00e3o</li> </ol>"},{"location":"complemento/","title":"Complemento","text":""},{"location":"complemento/#complemento","title":"Complemento","text":""},{"location":"complemento/#comecando-com-python-e-c","title":"Come\u00e7ando com Python e C","text":""},{"location":"complemento/#python","title":"Python","text":"<p>Para come\u00e7ar com Python:</p> <ul> <li>Instale Python via python.org.</li> <li>Utilize IDEs como PyCharm ou Jupyter Notebook para desenvolver seus projetos.</li> </ul>"},{"location":"complemento/#c","title":"C","text":"<p>Para come\u00e7ar com C:</p> <ul> <li>Instale um compilador como GCC ou use IDEs como Code::Blocks ou Dev-C++.</li> <li>Familiarize-se com conceitos b\u00e1sicos como ponteiros e aloca\u00e7\u00e3o din\u00e2mica.</li> </ul>"},{"location":"counting_sort/","title":"Counting Sort","text":""},{"location":"counting_sort/#counting-sort","title":"Counting Sort","text":""},{"location":"counting_sort/#introducao","title":"\ud83d\udcd6 Introdu\u00e7\u00e3o","text":"<p>O Counting Sort \u00e9 um algoritmo de ordena\u00e7\u00e3o baseado na contagem da frequ\u00eancia de elementos. Em vez de comparar elementos diretamente, ele cria um array auxiliar para armazenar a frequ\u00eancia de cada valor e, a partir dessas informa\u00e7\u00f5es, gera a lista ordenada. Foi proposto por Harold H. Seward em 1954 e \u00e9 considerado um dos algoritmos mais r\u00e1pidos quando aplicado a dados com um intervalo limitado.</p>"},{"location":"counting_sort/#curiosidade-sobre-o-counting-sort-e-frequentemente-usado-em-ambientes-onde-os-dados-sao-pequenos-e-inteiros-como-a-ordenacao-de-notas-escolares-ou-distribuicoes-numericas-com-pequenos-intervalos","title":"Curiosidade sobre o Counting Sort: \"\u00c9 frequentemente usado em ambientes onde os dados s\u00e3o pequenos e inteiros, como a ordena\u00e7\u00e3o de notas escolares ou distribui\u00e7\u00f5es num\u00e9ricas com pequenos intervalos.\"","text":""},{"location":"counting_sort/#motivacao-do-uso-e-desenvolvimento","title":"Motiva\u00e7\u00e3o do Uso e Desenvolvimento","text":"<p>O Counting Sort foi desenvolvido para ser eficiente em cen\u00e1rios onde a faixa de valores dos elementos a serem ordenados \u00e9 limitada, especialmente quando a diferen\u00e7a entre o valor m\u00e1ximo e o valor m\u00ednimo n\u00e3o \u00e9 muito grande. Sua principal vantagem \u00e9 o desempenho em tempo linear O(n + k), onde <code>n</code> \u00e9 o n\u00famero de elementos a ser ordenados e <code>k</code> \u00e9 o intervalo de valores, o que o torna mais eficiente do que algoritmos de compara\u00e7\u00e3o em determinadas situa\u00e7\u00f5es.</p>"},{"location":"counting_sort/#funcionamento-do-algoritmo","title":"Funcionamento do Algoritmo","text":""},{"location":"counting_sort/#passo-a-passo","title":"Passo a Passo","text":"<ol> <li>\ud83d\udcdd Contagem das Frequ\u00eancias: Um array de contagem \u00e9 criado, onde cada \u00edndice representar\u00e1 um valor poss\u00edvel na lista de entrada e armazenar\u00e1 o n\u00famero de ocorr\u00eancias desse valor.</li> <li>\ud83d\udd22 C\u00e1lculo da Posi\u00e7\u00e3o: Com base no array de contagem, o algoritmo determina a posi\u00e7\u00e3o final de cada elemento na lista ordenada.</li> <li>\ud83d\udccd Constru\u00e7\u00e3o da Lista Ordenada: Utilizando as informa\u00e7\u00f5es do array de contagem, a lista original \u00e9 reconstitu\u00edda de forma ordenada.</li> </ol> <p>Exemplo de Contagem e Ordena\u00e7\u00e3o:</p> <p>Lista original: <code>[4, 2, 2, 8, 3, 3, 1]</code></p> <ul> <li>Contagem de Frequ\u00eancias:</li> </ul> <pre><code>Frequ\u00eancias: [0, 1, 2, 2, 1, 0, 0, 0, 1]\n</code></pre> <p>Onde o \u00edndice representa os n\u00fameros e o valor armazena a frequ\u00eancia.</p> <ul> <li>Reconstru\u00e7\u00e3o da Lista Ordenada:   Resultado final: <code>[1, 2, 2, 3, 3, 4, 8]</code></li> </ul>"},{"location":"counting_sort/#complexidade","title":"\ud83d\udcca Complexidade","text":"<ul> <li>Melhor Caso: O(n + k)</li> <li>Pior Caso: O(n + k)</li> <li>Caso M\u00e9dio: O(n + k)</li> </ul> <p>Embora a complexidade de tempo seja linear O(n + k), ela depende fortemente de <code>k</code>, o intervalo dos elementos. Em situa\u00e7\u00f5es onde <code>k</code> \u00e9 muito maior que <code>n</code>, o Counting Sort pode ser ineficiente devido ao uso de mem\u00f3ria adicional.</p>"},{"location":"counting_sort/#implementacao","title":"\ud83d\udcbb Implementa\u00e7\u00e3o","text":""},{"location":"counting_sort/#python","title":"Python","text":"<pre><code>def counting_sort(arr):\n    # Encontrar o valor m\u00e1ximo na lista\n    max_val = max(arr)\n    min_val = min(arr)\n\n    # Tamanho do intervalo de valores\n    range_of_elements = max_val - min_val + 1\n\n    # Criando um array de contagem com base no intervalo\n    count = [0] * range_of_elements\n    output = [0] * len(arr)\n\n    # Contar a ocorr\u00eancia de cada valor\n    for num in arr:\n        count[num - min_val] += 1\n\n    # Alterar o array de contagem para armazenar a posi\u00e7\u00e3o correta de cada n\u00famero\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n\n    # Construir o array ordenado\n    for num in reversed(arr):\n        output[count[num - min_val] - 1] = num\n        count[num - min_val] -= 1\n\n    return output\n</code></pre>"},{"location":"counting_sort/#c","title":"C","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid countingSort(int arr[], int n);\n\nvoid countingSort(int arr[], int n) {\n    int max_val = arr[0];\n    int min_val = arr[0];\n\n    // Encontrar o valor m\u00e1ximo e m\u00ednimo\n    for (int i = 1; i &lt; n; i++) {\n        if (arr[i] &gt; max_val) {\n            max_val = arr[i];\n        }\n        if (arr[i] &lt; min_val) {\n            min_val = arr[i];\n        }\n    }\n\n    // Tamanho do intervalo\n    int range = max_val - min_val + 1;\n    int *count = (int *)calloc(range, sizeof(int));\n    int *output = (int *)malloc(n * sizeof(int));\n\n    // Contagem da frequ\u00eancia dos elementos\n    for (int i = 0; i &lt; n; i++) {\n        count[arr[i] - min_val]++;\n    }\n\n    // Atualizar o array de contagem\n    for (int i = 1; i &lt; range; i++) {\n        count[i] += count[i - 1];\n    }\n\n    // Construir o array ordenado\n    for (int i = n - 1; i &gt;= 0; i--) {\n        output[count[arr[i] - min_val] - 1] = arr[i];\n        count[arr[i] - min_val]--;\n    }\n\n    // Copiar os elementos ordenados de volta para o array original\n    for (int i = 0; i &lt; n; i++) {\n        arr[i] = output[i];\n    }\n\n    free(count);\n    free(output);\n}\n</code></pre>"},{"location":"counting_sort/#casos-de-uso","title":"\ud83d\udee0\ufe0f Casos de Uso","text":"<ul> <li>Distribui\u00e7\u00f5es num\u00e9ricas com um intervalo limitado: O Counting Sort \u00e9 altamente eficiente para ordenar n\u00fameros inteiros em intervalos pequenos.</li> <li>Problemas de ordena\u00e7\u00e3o com dados discretos: Quando o intervalo de dados conhecidos \u00e9 pequeno, como ordenar notas de alunos, idades, ou classifica\u00e7\u00f5es.</li> </ul>"},{"location":"counting_sort/#vantagens-e-desvantagens","title":"\u2696\ufe0f Vantagens e Desvantagens","text":""},{"location":"counting_sort/#vantagens","title":"\u2705 Vantagens","text":"<ul> <li>Tempo Linear: A principal vantagem \u00e9 sua complexidade de tempo de O(n + k), tornando-o muito r\u00e1pido para intervalos pequenos.</li> <li>Estabilidade: Pode ser implementado de forma est\u00e1vel, o que significa que a ordem relativa dos elementos iguais ser\u00e1 mantida.</li> <li>In-place: Quando o intervalo de dados \u00e9 restrito, o algoritmo usa pouca mem\u00f3ria adicional.</li> </ul>"},{"location":"counting_sort/#desvantagens","title":"\u274c Desvantagens","text":"<ul> <li>Ineficiente para grandes intervalos: Se <code>k</code>, o intervalo dos valores, for muito grande em rela\u00e7\u00e3o a <code>n</code>, o algoritmo pode consumir grande quantidade de mem\u00f3ria e tempo.</li> <li>Requer conhecimento pr\u00e9vio do intervalo de valores: O algoritmo exige que o intervalo dos dados seja conhecido e bem limitado.</li> </ul>"},{"location":"counting_sort/#curiosidades","title":"\ud83d\udcdd Curiosidades","text":"<ul> <li>O Counting Sort \u00e9 frequentemente utilizado em sistemas de ordena\u00e7\u00e3o paralela devido \u00e0 sua capacidade de dividir o trabalho de contagem de frequ\u00eancia entre v\u00e1rias unidades.</li> <li>Ele \u00e9 particularmente \u00fatil quando a distribui\u00e7\u00e3o dos dados \u00e9 bastante desigual e o intervalo de valores \u00e9 relativamente pequeno.</li> </ul>"},{"location":"counting_sort/#grafico-comparativo-com-outros-algoritmos","title":"Gr\u00e1fico Comparativo com Outros Algoritmos","text":"Algoritmo Melhor Caso Pior Caso Caso M\u00e9dio Counting Sort O(n + k) O(n + k) O(n + k) Merge Sort O(n log n) O(n log n) O(n log n) Quick Sort O(n log n) O(n\u00b2) O(n log n) Heap Sort O(n log n) O(n log n) O(n log n)"},{"location":"counting_sort/#elementos-repetidos-no-counting-sort","title":"Elementos Repetidos no Counting Sort","text":"<p>O Counting Sort mant\u00e9m a estabilidade, o que significa que ele preserva a ordem original dos elementos duplicados. Como ele processa cada elemento de forma ordenada a partir do seu \u00edndice, ele sempre coloca as inst\u00e2ncias iguais em suas posi\u00e7\u00f5es apropriadas sem reorden\u00e1-las. Assim, se tivermos a lista <code>[4, 2, 2, 8, 3, 3, 1]</code>, a sa\u00edda ser\u00e1 <code>[1, 2, 2, 3, 3, 4, 8]</code>, com as duas inst\u00e2ncias do <code>2</code> e <code>3</code> mantendo sua ordem original.</p>"},{"location":"counting_sort/#importancia-dos-algoritmos-de-ordenacao","title":"Import\u00e2ncia dos Algoritmos de Ordena\u00e7\u00e3o","text":"<p>Os algoritmos de ordena\u00e7\u00e3o como o Counting Sort s\u00e3o essenciais para muitos sistemas computacionais que dependem de listagens ou distribui\u00e7\u00f5es, tais como algoritmos de an\u00e1lise de dados, classifica\u00e7\u00e3o em bases de dados, e sistemas de recomenda\u00e7\u00e3o.</p>"},{"location":"counting_sort/#programacao-competitiva","title":"Programa\u00e7\u00e3o Competitiva","text":"<p>Na programa\u00e7\u00e3o competitiva, algoritmos como o Counting Sort podem ser muito \u00fateis para resolver problemas envolvendo a contagem e distribui\u00e7\u00e3o de elementos de maneira eficiente. Al\u00e9m disso, seu uso pode melhorar drasticamente o desempenho em problemas com dados num\u00e9ricos limitados.</p>"},{"location":"counting_sort/#quiz-interativo","title":"Quiz Interativo","text":"<ol> <li> <p>Em qual situa\u00e7\u00e3o o Counting Sort \u00e9 mais eficiente?</p> </li> <li> <p>O Counting Sort \u00e9 considerado um algoritmo:</p> </li> <li> <p>Qual \u00e9 a principal desvantagem do Counting Sort?</p> </li> </ol>"},{"location":"counting_sort/#recursos-graficos-na-web","title":"Recursos Gr\u00e1ficos na Web","text":"<ul> <li>Visualgo</li> <li>GeeksForGeeks</li> </ul>"},{"location":"counting_sort/#dicas-para-programar-no-leetcode","title":"Dicas para Programar no LeetCode","text":"<ol> <li>Esteja ciente dos limites de intervalo: O Counting Sort \u00e9 \u00f3timo quando o intervalo \u00e9 pequeno. Se voc\u00ea suspeitar que o intervalo \u00e9 grande, considere usar outros algoritmos.</li> <li>Aproveite as vers\u00f5es est\u00e1veis: A estabilidade do Counting Sort pode ser \u00fatil para problemas onde a ordem relativa dos elementos iguais importa.</li> <li>Pratique sua implementa\u00e7\u00e3o em ambientes sem muitos recursos para testar seu desempenho.</li> </ol>"},{"location":"counting_sort/#video-explicativo","title":"\ud83c\udfa5 V\u00eddeo Explicativo","text":""},{"location":"counting_sort/#link-do-video","title":"Link do v\u00eddeo","text":""},{"location":"counting_sort/#referencias","title":"Refer\u00eancias","text":"<p>Esses detalhes adicionais enriquecem a documenta\u00e7\u00e3o do Counting Sort e ajudam a compreender melhor sua import\u00e2ncia na ci\u00eancia da computa\u00e7\u00e3o.</p> <p>Cita\u00e7\u00e3o:</p> <ol> <li>Counting Sort - Desenvolvendo Software</li> <li>CountingSort-Algorithm - GitHub</li> <li>Complexidade Assint\u00f3tica - Algoritmos de Ordena\u00e7\u00e3o (PDF)</li> <li>Counting sort \u2013 Wikip\u00e9dia</li> <li>Ordena\u00e7\u00e3o Linear: Counting sort - Jo\u00e3o Arthur</li> <li>Algoritmos de Ordena\u00e7\u00e3o: An\u00e1lise e Compara\u00e7\u00e3o - DevMedia</li> <li>M\u00e9todos de Ordena\u00e7\u00e3o: Quick, Radix, Counting, Bucket (Sort) - UFG (PDF)</li> <li>Apresenta\u00e7\u00e3o sobre Ordena\u00e7\u00e3o por Contagem - CIn UFPE (PPT)</li> </ol>"},{"location":"heap_sort/","title":"Heap Sort","text":""},{"location":"heap_sort/#heap-sort","title":"Heap Sort","text":""},{"location":"heap_sort/#introducao","title":"\ud83d\udcd6 Introdu\u00e7\u00e3o","text":"<p>O Heap Sort \u00e9 um algoritmo de ordena\u00e7\u00e3o baseado na estrutura de dados chamada heap, que pode ser max heap ou min heap. Ele utiliza a t\u00e9cnica de sele\u00e7\u00e3o e ajuste para ordenar os elementos. Desenvolvido por J. W. J. Williams em 1964, o Heap Sort \u00e9 eficiente e possui uma complexidade de tempo de O(n log n) em todos os casos, o que o torna um dos algoritmos de ordena\u00e7\u00e3o eficientes.</p>"},{"location":"heap_sort/#curiosidade-sobre-o-heap-o-heap-sendo-uma-estrutura-de-arvore-binaria-garante-uma-insercao-e-remocao-de-elementos-de-maneira-eficiente-especialmente-em-problemas-que-envolvem-otimizacao-como-agendamento-e-filas-de-prioridade","title":"Curiosidade sobre o Heap: \"O heap, sendo uma estrutura de \u00e1rvore bin\u00e1ria, garante uma inser\u00e7\u00e3o e remo\u00e7\u00e3o de elementos de maneira eficiente, especialmente em problemas que envolvem otimiza\u00e7\u00e3o como agendamento e filas de prioridade.\"","text":""},{"location":"heap_sort/#motivacao-do-uso-e-desenvolvimento","title":"Motiva\u00e7\u00e3o do Uso e Desenvolvimento","text":"<p>O Heap Sort foi desenvolvido para resolver problemas de ordena\u00e7\u00e3o em que a efici\u00eancia e o uso eficiente da mem\u00f3ria s\u00e3o cruciais. Ao contr\u00e1rio de algoritmos como o Merge Sort, que exigem espa\u00e7o adicional, o Heap Sort \u00e9 um algoritmo in-place e n\u00e3o precisa de mem\u00f3ria extra. Ele \u00e9 frequentemente utilizado quando o espa\u00e7o de mem\u00f3ria \u00e9 limitado ou quando \u00e9 necess\u00e1rio um algoritmo eficiente em termos de complexidade de tempo.</p>"},{"location":"heap_sort/#funcionamento-do-algoritmo","title":"Funcionamento do Algoritmo","text":""},{"location":"heap_sort/#passo-a-passo","title":"Passo a Passo","text":"<ol> <li>\ud83d\udee0\ufe0f Constru\u00e7\u00e3o do Heap: A estrutura de heap \u00e9 constru\u00edda a partir do array original. No caso do Max Heap, a maior chave estar\u00e1 na raiz da \u00e1rvore, e as chaves dos n\u00f3s filhos ser\u00e3o menores que a chave do n\u00f3 pai.</li> <li>\ud83c\udfd7\ufe0f Remo\u00e7\u00e3o e Ajuste: O elemento na raiz (m\u00e1ximo ou m\u00ednimo) \u00e9 removido e colocado na posi\u00e7\u00e3o final do array. Em seguida, o heap \u00e9 ajustado para manter a propriedade de heap.</li> <li>\ud83d\udd04 Repeti\u00e7\u00e3o: O passo de remo\u00e7\u00e3o e ajuste \u00e9 repetido at\u00e9 que o heap tenha sido completamente ordenado.</li> </ol> <p>Exemplo de Constru\u00e7\u00e3o de um Heap:</p> <p>Lista original: <code>[4, 10, 3, 5, 1]</code></p> <ul> <li>Constru\u00e7\u00e3o do Max Heap: <code>[10, 5, 3, 4, 1]</code></li> <li>Remo\u00e7\u00e3o da raiz (10) e ajuste: A raiz \u00e9 colocada no final e o heap \u00e9 ajustado para <code>[5, 4, 3, 1]</code>.</li> <li>Repeti\u00e7\u00e3o do processo at\u00e9 que a lista esteja ordenada: <code>[1, 3, 4, 5, 10]</code></li> </ul>"},{"location":"heap_sort/#complexidade","title":"\ud83d\udcca Complexidade","text":"<ul> <li>Melhor Caso: O(n log n)</li> <li>Pior Caso: O(n log n)</li> <li>Caso M\u00e9dio: O(n log n)</li> </ul> <p>Embora a complexidade seja O(n log n), o Heap Sort tem a vantagem de ser um algoritmo in-place, ou seja, n\u00e3o necessita de espa\u00e7o extra significativo, exceto para a pilha de chamadas recursivas.</p>"},{"location":"heap_sort/#implementacao","title":"\ud83d\udcbb Implementa\u00e7\u00e3o","text":""},{"location":"heap_sort/#python","title":"Python","text":"<pre><code>def heapify(arr, n, i):\n    largest = i  # Inicializa o maior como raiz\n    left = 2 * i + 1  # Esquerdo = 2*i + 1\n    right = 2 * i + 2  # Direito = 2*i + 2\n\n    # Se o filho da esquerda for maior que a raiz\n    if left &lt; n and arr[left] &gt; arr[largest]:\n        largest = left\n\n    # Se o filho da direita for maior que o maior at\u00e9 agora\n    if right &lt; n and arr[right] &gt; arr[largest]:\n        largest = right\n\n    # Se o maior n\u00e3o for a raiz\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # Troca\n        heapify(arr, n, largest)\n\ndef heap_sort(arr):\n    n = len(arr)\n\n    # Construir o heap (reorganizar o array)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # Um por um, remover os elementos do heap\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # Troca\n        heapify(arr, i, 0)\n\n    return arr\n</code></pre>"},{"location":"heap_sort/#c","title":"C","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid heapify(int arr[], int n, int i);\nvoid heapSort(int arr[], int n);\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])\n        largest = left;\n\n    if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])\n        largest = right;\n\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i &gt;= 0; i--)\n        heapify(arr, n, i);\n\n    for (int i = n - 1; i &gt;= 0; i--) {\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n\n        heapify(arr, i, 0);\n    }\n}\n</code></pre>"},{"location":"heap_sort/#casos-de-uso","title":"\ud83d\udee0\ufe0f Casos de Uso","text":"<ul> <li>Algoritmos de otimiza\u00e7\u00e3o que exigem a ordena\u00e7\u00e3o de elementos de forma eficiente.</li> <li>Filas de prioridade, especialmente quando \u00e9 necess\u00e1rio inserir e remover elementos frequentemente.</li> <li>Problemas de sele\u00e7\u00e3o em que o objetivo \u00e9 encontrar o k-\u00e9simo maior ou menor elemento rapidamente.</li> </ul>"},{"location":"heap_sort/#vantagens-e-desvantagens","title":"\u2696\ufe0f Vantagens e Desvantagens","text":""},{"location":"heap_sort/#vantagens","title":"\u2705 Vantagens","text":"<ul> <li>Efici\u00eancia: Complexidade de O(n log n) em todos os cen\u00e1rios.</li> <li>In-place: N\u00e3o requer mem\u00f3ria adicional significativa.</li> <li>Vers\u00e1til: Pode ser usado para problemas de fila de prioridade e sele\u00e7\u00e3o de elementos.</li> </ul>"},{"location":"heap_sort/#desvantagens","title":"\u274c Desvantagens","text":"<ul> <li>N\u00e3o est\u00e1vel: N\u00e3o mant\u00e9m a ordem relativa de elementos iguais.</li> <li>Mais lento que o Merge Sort em muitos cen\u00e1rios, especialmente com dados parcialmente ordenados.</li> </ul>"},{"location":"heap_sort/#curiosidades","title":"\ud83d\udcdd Curiosidades","text":"<ul> <li>O Heap Sort \u00e9 fundamental em muitas implementa\u00e7\u00f5es de filas de prioridade, sendo utilizado, por exemplo, nos algoritmos de Dijkstra para encontrar o caminho mais curto.</li> <li>\u00c9 um dos algoritmos que prova a rela\u00e7\u00e3o entre a manipula\u00e7\u00e3o de heaps e a efici\u00eancia em otimizar problemas complexos.</li> </ul>"},{"location":"heap_sort/#grafico-comparativo-com-outros-algoritmos","title":"Gr\u00e1fico Comparativo com Outros Algoritmos","text":"Algoritmo Melhor Caso Pior Caso Caso M\u00e9dio Heap Sort O(n log n) O(n log n) O(n log n) Merge Sort O(n log n) O(n log n) O(n log n) Quick Sort O(n log n) O(n\u00b2) O(n log n) Insertion Sort O(n) O(n\u00b2) O(n\u00b2)"},{"location":"heap_sort/#elementos-repetidos-no-heap-sort","title":"Elementos Repetidos no Heap Sort","text":"<p>Embora o Heap Sort seja n\u00e3o est\u00e1vel, ele ainda garante que todos os elementos ser\u00e3o corretamente ordenados, incluindo elementos duplicados. Quando os elementos iguais s\u00e3o encontrados, eles s\u00e3o colocados de acordo com a sua posi\u00e7\u00e3o no heap durante o processo de sele\u00e7\u00e3o e ajuste. No entanto, a ordem relativa entre elementos iguais pode ser alterada.</p>"},{"location":"heap_sort/#importancia-dos-algoritmos-de-ordenacao","title":"Import\u00e2ncia dos Algoritmos de Ordena\u00e7\u00e3o","text":"<p>Algoritmos como o Heap Sort s\u00e3o essenciais em aplica\u00e7\u00f5es que exigem otimiza\u00e7\u00e3o, como jogos, sistemas de distribui\u00e7\u00e3o de tarefas e sistemas de banco de dados. Sua efic\u00e1cia em espa\u00e7os de mem\u00f3ria limitados \u00e9 crucial quando se trata de sistemas em tempo real.</p>"},{"location":"heap_sort/#programacao-competitiva","title":"Programa\u00e7\u00e3o Competitiva","text":"<p>Dominar o Heap Sort \u00e9 uma habilidade fundamental na programa\u00e7\u00e3o competitiva. Ele \u00e9 frequentemente usado em problemas que exigem uma manipula\u00e7\u00e3o eficiente de filas de prioridade ou a solu\u00e7\u00e3o de problemas de otimiza\u00e7\u00e3o, como o problema de sele\u00e7\u00e3o de k-\u00e9simos maiores/menores elementos.</p>"},{"location":"heap_sort/#quiz-interativo","title":"Quiz Interativo","text":"<ol> <li> <p>Qual \u00e9 a principal vantagem do Heap Sort em compara\u00e7\u00e3o com o Merge Sort?</p> </li> <li> <p>O Heap Sort \u00e9 considerado um algoritmo:</p> </li> <li> <p>Qual \u00e9 a complexidade do Heap Sort no pior caso?</p> </li> </ol>"},{"location":"heap_sort/#recursos-graficos-na-web","title":"Recursos Gr\u00e1ficos na Web","text":"<ul> <li>Visualgo</li> <li>GeeksForGeeks</li> </ul>"},{"location":"heap_sort/#dicas-para-programar-no-leetcode","title":"Dicas para Programar no LeetCode","text":"<ol> <li>Estude as estruturas de dados como o heap, j\u00e1 que elas frequentemente aparecem em problemas do LeetCode.</li> <li>Pratique manipula\u00e7\u00e3o de filas de prioridade utilizando heap sort.</li> <li>Teste seu c\u00f3digo com entradas de diferentes tamanhos e padr\u00f5es para garantir efici\u00eancia.</li> </ol>"},{"location":"heap_sort/#video-explicativo","title":"\ud83c\udfa5 V\u00eddeo Explicativo","text":""},{"location":"heap_sort/#link-do-video","title":"Link do v\u00eddeo","text":""},{"location":"heap_sort/#referencias","title":"Refer\u00eancias","text":"<p>Esses detalhes adicionais enriquecem a documenta\u00e7\u00e3o do Heap Sort e ajudam a compreender melhor sua import\u00e2ncia na ci\u00eancia da computa\u00e7\u00e3o.</p> <ol> <li>Heapsort - Wikip\u00e9dia</li> <li>Aula 16 - HeapSort (PDF)</li> <li>Algoritmo do Heapsort - GitHub</li> <li>09-heapSort.pdf - EACH-Usp</li> <li>An\u00e1lise de algoritmos - Heapsort (PDF)</li> <li>HeapSort - Delano M. Beder (PDF)</li> <li>Heapsort - Artigo de Prof. Fl\u00e1vio Rog\u00e9rio Uber (PDF)</li> <li>HeapSort em Java - Exemplo de implementa\u00e7\u00e3o</li> </ol>"},{"location":"insertion_sort/","title":"Insertion Sort","text":""},{"location":"insertion_sort/#insertion-sort","title":"Insertion Sort","text":""},{"location":"insertion_sort/#introducao","title":"\u2728 Introdu\u00e7\u00e3o","text":"<p>O Insertion Sort \u00e9 um algoritmo simples e eficiente para ordenar listas pequenas. Ele funciona de maneira semelhante \u00e0 organiza\u00e7\u00e3o de cartas de um baralho: voc\u00ea seleciona uma carta de cada vez e a posiciona no local correto entre as outras.</p>"},{"location":"insertion_sort/#motivacao-do-uso-e-desenvolvimento","title":"Motiva\u00e7\u00e3o do Uso e Desenvolvimento","text":"<p>O Insertion Sort \u00e9 muito \u00fatil em situa\u00e7\u00f5es onde a simplicidade da implementa\u00e7\u00e3o \u00e9 crucial e os conjuntos de dados s\u00e3o pequenos ou quase ordenados. Sua abordagem intuitiva faz com que seja uma escolha popular para ensino de algoritmos de ordena\u00e7\u00e3o.</p>"},{"location":"insertion_sort/#funcionamento-do-algoritmo","title":"Funcionamento do Algoritmo","text":""},{"location":"insertion_sort/#passo-a-passo","title":"Passo a Passo","text":"<ol> <li>Selecionar um elemento: Comece com o segundo elemento da lista (o primeiro \u00e9 considerado j\u00e1 ordenado).</li> <li>Comparar: Compare este elemento com os elementos anteriores da lista.</li> <li>Reordenar: Insira o elemento na posi\u00e7\u00e3o correta na sublista ordenada.</li> <li>Repetir: Repita para todos os elementos at\u00e9 que a lista esteja completamente ordenada.</li> </ol> <p>Exemplo de Funcionamento:</p> <p>Lista original: <code>[5, 3, 8, 6]</code></p> <ul> <li>Passo 1: Selecionar <code>3</code>, comparar com <code>5</code> e inserir antes: <code>[3, 5, 8, 6]</code></li> <li>Passo 2: Selecionar <code>8</code>, nenhuma altera\u00e7\u00e3o necess\u00e1ria: <code>[3, 5, 8, 6]</code></li> <li>Passo 3: Selecionar <code>6</code>, inserir entre <code>5</code> e <code>8</code>: <code>[3, 5, 6, 8]</code></li> <li>Fim: Lista ordenada.</li> </ul> <p>Na primeira itera\u00e7\u00e3o, <code>3</code> \u00e9 comparado a <code>5</code> porque \u00e9 menor e, portanto, \u00e9 deslocado para a primeira posi\u00e7\u00e3o. Posteriormente, \u201c6\u201d encontra seu lugar entre <code>5</code> e <code>8</code>, demonstrando como o algoritmo refina progressivamente a ordem.</p>"},{"location":"insertion_sort/#complexidade","title":"\ud83d\udcca Complexidade","text":"<ul> <li>Melhor Caso: O(n) \u2013 quando a lista j\u00e1 est\u00e1 ordenada.</li> <li>Pior Caso: O(n\u00b2) \u2013 quando a lista est\u00e1 em ordem decrescente.</li> <li>Caso M\u00e9dio: O(n\u00b2).</li> </ul> <p>O Insertion Sort tem a vantagem de ser um algoritmo in-place, ou seja, n\u00e3o requer mem\u00f3ria adicional significativa.</p>"},{"location":"insertion_sort/#implementacao","title":"\ud83d\udcbb Implementa\u00e7\u00e3o","text":""},{"location":"insertion_sort/#python","title":"Python","text":"<pre><code>def insertion_sort(array):\n    for i in range(1, len(array)):\n        key = array[i]\n        j = i - 1\n        while j &gt;= 0 and array[j] &gt; key:\n            array[j + 1] = array[j]\n            j -= 1\n        array[j + 1] = key\n    return array\n</code></pre>"},{"location":"insertion_sort/#c","title":"C","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i &lt; n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n\n        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n</code></pre>"},{"location":"insertion_sort/#casos-de-uso","title":"\ud83d\udee0\ufe0f Casos de Uso","text":"<ul> <li>Conjuntos de dados pequenos.</li> <li>Dados quase ordenados.</li> <li>Situa\u00e7\u00f5es educacionais para ensino de algoritmos de ordena\u00e7\u00e3o.</li> </ul>"},{"location":"insertion_sort/#vantagens-e-desvantagens","title":"\u2696\ufe0f Vantagens e Desvantagens","text":""},{"location":"insertion_sort/#vantagens","title":"\u2705 Vantagens","text":"<ul> <li>Simples e intuitivo de implementar.</li> <li>Excelente desempenho para listas pequenas.</li> <li>Est\u00e1vel, mantendo a ordem relativa de elementos iguais.</li> </ul>"},{"location":"insertion_sort/#desvantagens","title":"\u274c Desvantagens","text":"<ul> <li>Ineficiente para listas grandes.</li> <li>Complexidade O(n\u00b2) em muitos cen\u00e1rios.</li> </ul>"},{"location":"insertion_sort/#curiosidades","title":"Curiosidades","text":"<ul> <li>O Insertion Sort \u00e9 um dos algoritmos mais intuitivos e pode ser implementado \u00e0 m\u00e3o sem dificuldade.</li> <li>Seu conceito est\u00e1 relacionado ao m\u00e9todo que humanos frequentemente usam para ordenar cartas.</li> </ul>"},{"location":"insertion_sort/#grafico-comparativo-com-outros-algoritmos","title":"Gr\u00e1fico Comparativo com Outros Algoritmos","text":"Algoritmo Melhor Caso Pior Caso Caso M\u00e9dio Insertion Sort O(n) O(n\u00b2) O(n\u00b2) Bubble Sort O(n) O(n\u00b2) O(n\u00b2) Quick Sort O(n \\log n) O(n\u00b2) O(n \\log n) Merge Sort O(n \\log n) O(n \\log n) O(n \\log n)"},{"location":"insertion_sort/#como-o-insertion-sort-lida-com-elementos-repetidos","title":"Como o Insertion Sort lida com elementos repetidos","text":"<p>O Insertion Sort \u00e9 um algoritmo est\u00e1vel, ou seja, ele preserva a ordem relativa dos elementos iguais, tornando-o ideal para situa\u00e7\u00f5es onde essa caracter\u00edstica \u00e9 importante.</p>"},{"location":"insertion_sort/#importancia-dos-algoritmos-de-ordenacao","title":"Import\u00e2ncia dos Algoritmos de Ordena\u00e7\u00e3o","text":"<p>Os algoritmos de ordena\u00e7\u00e3o s\u00e3o essenciais na computa\u00e7\u00e3o para:</p> <ul> <li>Otimizar buscas e an\u00e1lises de dados.</li> <li>Organizar informa\u00e7\u00f5es para processamento.</li> <li>Facilitar opera\u00e7\u00f5es em bancos de dados.</li> </ul>"},{"location":"insertion_sort/#programacao-competitiva","title":"Programa\u00e7\u00e3o Competitiva","text":"<p>Embora o Insertion Sort seja pouco usado em competi\u00e7\u00f5es devido \u00e0 sua inefici\u00eancia em dados grandes, ele \u00e9 uma op\u00e7\u00e3o inicial simples para prototipa\u00e7\u00e3o e aprendizado.</p>"},{"location":"insertion_sort/#quiz-interativo","title":"Quiz Interativo","text":"<ol> <li> <p>Qual \u00e9 a complexidade do Insertion Sort no melhor caso?</p> </li> <li> <p>O Insertion Sort \u00e9 um algoritmo:</p> </li> <li> <p>Para quais conjuntos de dados o Insertion Sort \u00e9 mais eficiente?</p> </li> </ol>"},{"location":"insertion_sort/#recursos-graficos-na-web","title":"Recursos Gr\u00e1ficos na Web","text":"<ul> <li>Visualgo</li> <li>GeeksforGeeks</li> </ul>"},{"location":"insertion_sort/#dicas-para-programar-no-leetcode","title":"Dicas para Programar no LeetCode","text":"<ol> <li>Entenda o problema: avalie quando usar Insertion Sort em desafios.</li> <li>Explore varia\u00e7\u00f5es, como a ordena\u00e7\u00e3o em ordem decrescente.</li> <li>Analise cen\u00e1rios adequados, priorizando listas pequenas ou quase ordenadas.</li> </ol>"},{"location":"insertion_sort/#video-explicativo","title":"\ud83c\udfa5 V\u00eddeo Explicativo","text":""},{"location":"insertion_sort/#link-do-video","title":"Link do v\u00eddeo","text":""},{"location":"insertion_sort/#referencias","title":"Refer\u00eancias","text":"<p>Esses detalhes adicionais enriquecem a documenta\u00e7\u00e3o do Insertion Sort e ajudam a compreender melhor sua import\u00e2ncia na ci\u00eancia da computa\u00e7\u00e3o.</p> <p>Cita\u00e7\u00e3o:</p> <ol> <li>Jo\u00e3o Arthur - Insertion Sort</li> <li>Como Programar - Desvendando o Algoritmo de Ordena\u00e7\u00e3o Insertion Sort</li> <li>Blog Cyberini - Insertion Sort</li> <li>Paulo R. Lisboa de Almeida - Aula 9 - Insertion Sort (PDF)</li> <li>Akira - O Algoritmo Insertion Sort</li> <li>Wikipedia - Insertion sort</li> <li>Paulo R. Lisboa de Almeida - Aula 8 - Insertion Sort - An\u00e1lise (PDF)</li> <li>UFG - M\u00e9todos de Ordena\u00e7\u00e3o: Selection, Insertion, Bubble, Merge (Sort) (PDF)</li> </ol>"},{"location":"merge_sort/","title":"Merge Sort","text":""},{"location":"merge_sort/#merge-sort","title":"Merge Sort","text":""},{"location":"merge_sort/#introducao","title":"\ud83d\udcd6 Introdu\u00e7\u00e3o","text":"<p>O Merge Sort \u00e9 um algoritmo de ordena\u00e7\u00e3o eficiente que utiliza a t\u00e9cnica de divis\u00e3o e conquista. Criado por John von Neumann em 1945, este algoritmo se destaca pela sua efici\u00eancia e estabilidade, sendo amplamente utilizado em aplica\u00e7\u00f5es que exigem alta performance na ordena\u00e7\u00e3o de dados.</p>"},{"location":"merge_sort/#curiosidade-sobre-o-neumnn-as-festas-em-casa-de-von-neumann-eram-frequentes-famosas-e-longas","title":"Curiosidade sobre o Neumnn: \"As festas em casa de von Neumann eram frequentes, famosas, e longas.\"","text":""},{"location":"merge_sort/#motivacao-do-uso-e-desenvolvimento","title":"Motiva\u00e7\u00e3o do Uso e Desenvolvimento","text":"<p>O Merge Sort foi desenvolvido para resolver problemas de ordena\u00e7\u00e3o em grandes volumes de dados, onde a efici\u00eancia \u00e9 crucial. Sua abordagem divide o problema em partes menores, permitindo que cada parte seja resolvida independentemente antes de serem combinadas. Essa caracter\u00edstica torna o Merge Sort especialmente \u00fatil em ambientes onde a estabilidade da ordena\u00e7\u00e3o \u00e9 necess\u00e1ria, como na ordena\u00e7\u00e3o de registros com m\u00faltiplos campos.</p>"},{"location":"merge_sort/#funcionamento-do-algoritmo","title":"Funcionamento do Algoritmo","text":""},{"location":"merge_sort/#passo-a-passo","title":"Passo a Passo","text":"<ol> <li>\ud83e\ude93 Divis\u00e3o: A lista \u00e9 dividida ao meio at\u00e9 que cada sublista tenha apenas um elemento.</li> <li>\ud83e\udd1d Conquista: Cada sublista \u00e9 ordenada recursivamente.</li> <li>\ud83d\udd17 Mesclagem (Merge): As sublistas ordenadas s\u00e3o combinadas, comparando os elementos e organizando-os em ordem crescente.</li> </ol> <p>Exemplo de Divis\u00e3o e Mesclagem:</p> <p>Lista original: <code>[38, 27, 43, 3, 9, 82, 10]</code></p> <ul> <li> <p>Divis\u00e3o: <code>[38, 27, 43]</code> e <code>[3, 9, 82, 10]</code> , <code>[27, 43]</code> e <code>[3, 9]</code>, <code>[82, 10]</code></p> </li> <li> <p>Mesclagem: <code>[27, 38, 43]</code> e <code>[3, 9, 10, 82]</code>   Resultado final: <code>[3, 9, 10, 27, 38, 43, 82]</code></p> </li> </ul>"},{"location":"merge_sort/#complexidade","title":"\ud83d\udcca Complexidade","text":"<ul> <li>Melhor Caso: O(n \\log n)</li> <li>Pior Caso: O(n \\log n)</li> <li>Caso M\u00e9dio: O(n \\log n)</li> </ul> <p>O Merge Sort requer espa\u00e7o adicional de O(n) devido \u00e0 cria\u00e7\u00e3o de sublistas para a mesclagem.</p>"},{"location":"merge_sort/#implementacao","title":"\ud83d\udcbb Implementa\u00e7\u00e3o","text":""},{"location":"merge_sort/#python","title":"Python","text":"<pre><code>def merge_sort(array):\n    if len(array) &lt;= 1:\n        return array\n\n    meio = len(array) // 2\n    esquerda = array[:meio]\n    direita = array[meio:]\n\n    esquerda = merge_sort(esquerda)\n    direita = merge_sort(direita)\n\n    return merge(esquerda, direita)\n\ndef merge(esquerda, direita):\n    resultado = []\n    i = j = 0\n\n    while i &lt; len(esquerda) and j &lt; len(direita):\n        if esquerda[i] &lt;= direita[j]:\n            resultado.append(esquerda[i])\n            i += 1\n        else:\n            resultado.append(direita[j])\n            j += 1\n\n    while i &lt; len(esquerda):\n        resultado.append(esquerda[i])\n        i += 1\n\n    while j &lt; len(direita):\n        resultado.append(direita[j])\n        j += 1\n\n    return resultado\n</code></pre>"},{"location":"merge_sort/#c","title":"C","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid mergeSort(int arr[], int inicio, int fim);\nvoid merge(int arr[], int inicio, int meio, int fim);\n\nvoid mergeSort(int arr[], int inicio, int fim) {\n    if (inicio &lt; fim) {\n        int meio = inicio + (fim - inicio) / 2;\n        mergeSort(arr, inicio, meio);\n        mergeSort(arr, meio + 1, fim);\n        merge(arr, inicio, meio, fim);\n    }\n}\n\nvoid merge(int arr[], int inicio, int meio, int fim) {\n    int i = inicio;\n    int j = meio + 1;\n    int k = inicio;\n\n    int *temp = malloc((fim - inicio + 1) * sizeof(int));\n\n    while (i &lt;= meio &amp;&amp; j &lt;= fim) {\n        if (arr[i] &lt;= arr[j]) {\n            temp[k++] = arr[i++];\n        } else {\n            temp[k++] = arr[j++];\n        }\n    }\n\n    while (i &lt;= meio) {\n        temp[k++] = arr[i++];\n    }\n\n    while (j &lt;= fim) {\n        temp[k++] = arr[j++];\n    }\n\n    for (i = inicio; i &lt;= fim; i++) {\n        arr[i] = temp[i];\n    }\n\n    free(temp);\n}\n</code></pre>"},{"location":"merge_sort/#casos-de-uso","title":"\ud83d\udee0\ufe0f Casos de Uso","text":"<ul> <li>Ordena\u00e7\u00e3o em sistemas cr\u00edticos que exigem alta previsibilidade.</li> <li>Ordena\u00e7\u00e3o de grandes volumes de dados devido \u00e0 sua efici\u00eancia em O(n \\log n).</li> <li>Ambientes que precisam de um algoritmo est\u00e1vel.</li> </ul>"},{"location":"merge_sort/#vantagens-e-desvantagens","title":"\u2696\ufe0f Vantagens e Desvantagens","text":""},{"location":"merge_sort/#vantagens","title":"\u2705 Vantagens","text":"<ul> <li>Complexidade consistente: O(n \\log n) em qualquer cen\u00e1rio.</li> <li>Est\u00e1vel: Mant\u00e9m a ordem relativa de elementos iguais.</li> <li>Excelente para grandes conjuntos de dados.</li> </ul>"},{"location":"merge_sort/#desvantagens","title":"\u274c Desvantagens","text":"<ul> <li>Consome mais mem\u00f3ria devido \u00e0 cria\u00e7\u00e3o de sublistas.</li> <li>Menos eficiente para listas pequenas.</li> </ul>"},{"location":"merge_sort/#curiosidades","title":"\ud83d\udcdd Curiosidades","text":"<ul> <li>O Merge Sort \u00e9 frequentemente utilizado em linguagens como Lisp devido \u00e0 sua efici\u00eancia na manipula\u00e7\u00e3o de listas encadeadas.</li> <li>\u00c9 o algoritmo base para o TimSort utilizado no Python e Java.</li> </ul>"},{"location":"merge_sort/#grafico-comparativo-com-outros-algoritmos","title":"Gr\u00e1fico Comparativo com Outros Algoritmos","text":"Algoritmo Melhor Caso Pior Caso Caso M\u00e9dio Merge Sort O(n \\log n) (n \\log n) (n \\log n) Quick Sort O(n \\log n) O(n\u00b2) O(n \\log n) Bubble Sort O(n) O(n\u00b2) O(n\u00b2) Insertion Sort O(n) O(n\u00b2) O(n\u00b2)"},{"location":"merge_sort/#elementos-repetidos-no-merge-sort","title":"Elementos Repetidos no Merge sort","text":"<p>O Merge Sort \u00e9 um algoritmo de ordena\u00e7\u00e3o que se comporta de maneira eficiente e est\u00e1vel, mesmo em listas que cont\u00eam elementos repetidos.</p> <ul> <li>O algoritmo divide a lista em sublistas at\u00e9 que cada sublista contenha apenas um elemento. Isso significa que, se houver elementos repetidos, cada um deles ser\u00e1 tratado como uma entidade separada durante a divis\u00e3o. Durante a fase de mesclagem, os elementos das sublistas s\u00e3o comparados. Se dois elementos iguais forem encontrados (por exemplo, duas inst\u00e2ncias do n\u00famero 5), o algoritmo os manter\u00e1 na mesma ordem em que foram encontrados nas sublistas originais.</li> <li>Isso ocorre porque, ao mesclar, o Merge Sort sempre pega o primeiro elemento dispon\u00edvel de cada sublista. Se ambos os elementos forem iguais, o elemento da sublista \u00e0 esquerda ser\u00e1 escolhido primeiro, preservando sua posi\u00e7\u00e3o relativa. Ap\u00f3s todas as mesclagens, os elementos duplicados aparecer\u00e3o lado a lado na lista ordenada final. Por exemplo, ao ordenar a lista [4, 2, 5, 5, 1], o resultado ser\u00e1 [1, 2, 4, 5, 5], onde os dois 5 permanecem na mesma ordem relativa.</li> </ul>"},{"location":"merge_sort/#importancia-dos-algoritmos-de-ordenacao","title":"Import\u00e2ncia dos Algoritmos de Ordena\u00e7\u00e3o","text":"<p>Os algoritmos de ordena\u00e7\u00e3o s\u00e3o fundamentais na ci\u00eancia da computa\u00e7\u00e3o porque:</p> <ul> <li>Facilitam a busca eficiente de dados.</li> <li>Melhoram a performance de outros algoritmos que dependem da ordena\u00e7\u00e3o.</li> <li>S\u00e3o essenciais em aplica\u00e7\u00f5es pr\u00e1ticas como bancos de dados e sistemas operacionais.</li> </ul>"},{"location":"merge_sort/#programacao-competitiva","title":"Programa\u00e7\u00e3o Competitiva","text":"<p>A programa\u00e7\u00e3o competitiva envolve resolver problemas complexos sob restri\u00e7\u00f5es de tempo. O conhecimento sobre algoritmos como o Merge Sort \u00e9 crucial para otimizar solu\u00e7\u00f5es e garantir desempenho eficiente.</p>"},{"location":"merge_sort/#quiz-interativo","title":"Quiz Interativo","text":"<ol> <li> <p>Qual \u00e9 a complexidade do Merge Sort no pior caso?</p> </li> <li> <p>O Merge Sort \u00e9 um algoritmo:</p> </li> <li> <p>Em qual ano John von Neumann desenvolveu o Merge Sort?</p> </li> </ol>"},{"location":"merge_sort/#recursos-graficos-na-web","title":"Recursos Gr\u00e1ficos na Web","text":"<p>Para visualizar o funcionamento do Merge Sort e comparar com outros algoritmos:</p> <ul> <li>Visualgo</li> <li>HackerEarth</li> </ul>"},{"location":"merge_sort/#dicas-para-programar-no-leetcode","title":"Dicas para Programar no LeetCode","text":"<ol> <li>Entenda bem o problema antes de come\u00e7ar a codificar.</li> <li>Estude solu\u00e7\u00f5es existentes e analise diferentes abordagens.</li> <li>Teste seu c\u00f3digo com casos extremos para garantir robustez.</li> <li>Pratique regularmente para aprimorar suas habilidades em algoritmos.</li> </ol>"},{"location":"merge_sort/#video-explicativo","title":"\ud83c\udfa5 V\u00eddeo Explicativo","text":""},{"location":"merge_sort/#link-do-video","title":"Link do v\u00eddeo","text":""},{"location":"merge_sort/#referencias","title":"Refer\u00eancias","text":"<p>Esses detalhes adicionais enriquecem a documenta\u00e7\u00e3o do Merge Sort e ajudam a compreender melhor sua import\u00e2ncia na ci\u00eancia da computa\u00e7\u00e3o.</p> <p>Cita\u00e7\u00e3o:</p> <ol> <li>Wikipedia</li> <li>Stackoverflow</li> <li>Visualgo</li> <li>Geeks For Geeks</li> <li>Geeks For Geeks</li> <li>Code Mentor</li> <li>Developer Nvidia</li> <li>Github</li> <li>HSM - Stack Exchange</li> </ol>"},{"location":"quick_sort/","title":"Quick Sort","text":""},{"location":"quick_sort/#quick-sort","title":"Quick Sort","text":""},{"location":"quick_sort/#introducao","title":"\ud83d\udd6f\ufe0f Introdu\u00e7\u00e3o","text":"<p>O Quick Sort \u00e9 um algoritmo de ordena\u00e7\u00e3o eficiente e popular, baseado no princ\u00edpio de divis\u00e3o e conquista. Desenvolvido por Tony Hoare em 1960, este algoritmo \u00e9 amplamente utilizado devido \u00e0 sua simplicidade e excelente desempenho em grandes volumes de dados.</p> <p>Curiosidade: Tony Hoare tamb\u00e9m \u00e9 conhecido pela \"Hip\u00f3tese do Buraco de Mem\u00f3ria\" e pela famosa \"Null Pointer Exception\", que ele chamou de seu \"maior erro\".</p>"},{"location":"quick_sort/#motivacao","title":"Motiva\u00e7\u00e3o","text":"<p>O Quick Sort foi criado para resolver problemas de ordena\u00e7\u00e3o em situa\u00e7\u00f5es onde o desempenho e a flexibilidade s\u00e3o cruciais. Sua principal for\u00e7a est\u00e1 em dividir o problema em subproblemas menores, utilizando um elemento chamado piv\u00f4 para realizar essa separa\u00e7\u00e3o.</p> <p>Essa abordagem adapt\u00e1vel torna o Quick Sort ideal para aplica\u00e7\u00f5es que lidam com dados dispostos de formas variadas.</p>"},{"location":"quick_sort/#funcionamento-do-algoritmo","title":"Funcionamento do Algoritmo","text":""},{"location":"quick_sort/#passo-a-passo","title":"Passo a Passo","text":"<ol> <li>Sele\u00e7\u00e3o do Piv\u00f4: Escolhe-se um elemento da lista como piv\u00f4 (geralmente o \u00faltimo elemento ou um escolhido aleatoriamente).</li> <li>Particionamento: Elementos menores que o piv\u00f4 s\u00e3o movidos para a esquerda, enquanto os maiores v\u00e3o para a direita.</li> <li>Chamada Recursiva: O processo \u00e9 repetido recursivamente nas sublistas esquerda e direita at\u00e9 que a lista esteja completamente ordenada.</li> </ol> <p>Exemplo de Funcionamento:</p> <p>Lista original: <code>[10, 7, 8, 9, 1, 5]</code></p> <ul> <li>Escolhe-se o piv\u00f4: <code>5</code></li> <li>Particiona-se: <code>[1] | 5 | [10, 7, 8, 9]</code></li> <li>Recurs\u00e3o \u00e0 esquerda e \u00e0 direita at\u00e9 obter <code>[1, 5, 7, 8, 9, 10]</code>.</li> </ul>"},{"location":"quick_sort/#complexidade","title":"\ud83d\udcca Complexidade","text":"<ul> <li>Melhor Caso: O(n \\log n) \u2013 quando o piv\u00f4 divide a lista em metades iguais.</li> <li>Pior Caso: O(n\u00b2) \u2013 ocorre quando o piv\u00f4 \u00e9 sempre o maior ou menor elemento.</li> <li>Caso M\u00e9dio: O(n \\log n) \u2013 comportamento mais comum.</li> </ul> <p>O Quick Sort exige mem\u00f3ria adicional m\u00ednima, pois realiza a ordena\u00e7\u00e3o no local (in-place sorting).</p>"},{"location":"quick_sort/#implementacao","title":"\ud83d\udcbb Implementa\u00e7\u00e3o","text":""},{"location":"quick_sort/#em-python","title":"Em Python","text":"<pre><code>def quick_sort(array):\n    if len(array) &lt;= 1:\n        return array\n\n    piv\u00f4 = array[-1]  # Escolhe o \u00faltimo elemento como piv\u00f4\n    menores = [x for x in array[:-1] if x &lt;= piv\u00f4]\n    maiores = [x for x in array[:-1] if x &gt; piv\u00f4]\n\n    return quick_sort(menores) + [piv\u00f4] + quick_sort(maiores)\n</code></pre>"},{"location":"quick_sort/#em-c","title":"Em C","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid quickSort(int arr[], int low, int high);\nint partition(int arr[], int low, int high);\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low &lt; high) {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high]; // Escolhe o \u00faltimo elemento como piv\u00f4\n    int i = low - 1;\n\n    for (int j = low; j &lt; high; j++) {\n        if (arr[j] &lt; pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n\n    return i + 1;\n}\n</code></pre>"},{"location":"quick_sort/#casos-de-uso","title":"\ud83d\udd27 Casos de Uso","text":"<ul> <li>Aplicativos onde a velocidade de ordena\u00e7\u00e3o \u00e9 crucial.</li> <li>Cen\u00e1rios com pouca mem\u00f3ria dispon\u00edvel, pois o Quick Sort utiliza pouco espa\u00e7o adicional.</li> <li>Situa\u00e7\u00f5es onde a estabilidade da ordena\u00e7\u00e3o n\u00e3o \u00e9 necess\u00e1ria.</li> </ul>"},{"location":"quick_sort/#vantagens-e-desvantagens","title":"\u2696\ufe0f Vantagens e Desvantagens","text":"<ul> <li>Altamente eficiente em grandes conjuntos de dados.</li> <li>Requer pouca mem\u00f3ria adicional.</li> <li>Geralmente mais r\u00e1pido que outros algoritmos de ordena\u00e7\u00e3o.</li> </ul>"},{"location":"quick_sort/#desvantagens","title":"\u274c Desvantagens","text":"<ul> <li>Desempenho pode ser prejudicado em listas j\u00e1 ordenadas ou quase ordenadas.</li> <li>N\u00e3o preserva a estabilidade entre elementos iguais.</li> </ul>"},{"location":"quick_sort/#curiosidades","title":"\ud83d\udcdd Curiosidades","text":"<ul> <li>O Quick Sort \u00e9 utilizado em bibliotecas padr\u00e3o de linguagens como C++ e Python devido \u00e0 sua efici\u00eancia.</li> <li>Linguagens modernas implementam varia\u00e7\u00f5es do Quick Sort, como o Dual-Pivot Quick Sort.</li> </ul>"},{"location":"quick_sort/#comparativo-com-outros-algoritmos","title":"Comparativo com Outros Algoritmos","text":"Algoritmo Melhor Caso Pior Caso Caso M\u00e9dio Quick Sort O(n \\log n) O(n\u00b2) O(n \\log n) Merge Sort O(n \\log n) O(n \\log n) O(n \\log n) Bubble Sort O(n) O(n\u00b2) O(n\u00b2) Insertion Sort O(n) O(n\u00b2) O(n\u00b2)"},{"location":"quick_sort/#elementos-repetidos-no-merge-sort","title":"Elementos Repetidos no Merge sort","text":"<p>Em listas com elementos repetidos, o Quick Sort pode alterar a ordem relativa desses elementos, j\u00e1 que n\u00e3o \u00e9 est\u00e1vel. Contudo, ele agrupa todas as ocorr\u00eancias do mesmo valor de forma eficiente.</p>"},{"location":"quick_sort/#importancia-dos-algoritmos-de-ordenacao","title":"\ud83d\udd0d Import\u00e2ncia dos Algoritmos de Ordena\u00e7\u00e3o","text":"<p>Os algoritmos de ordena\u00e7\u00e3o s\u00e3o essenciais para:</p> <ul> <li>Facilitar buscas eficientes em dados.</li> <li>Auxiliar em opera\u00e7\u00f5es como fus\u00e3o de bases de dados.</li> <li>Melhorar o desempenho em aplica\u00e7\u00f5es complexas, como intelig\u00eancia artificial.</li> </ul>"},{"location":"quick_sort/#quick-sort-na-programacao-competitiva","title":"\ud83c\udfaf Quick Sort na Programa\u00e7\u00e3o Competitiva","text":"<p>No contexto da programa\u00e7\u00e3o competitiva, o Quick Sort \u00e9 amplamente utilizado por sua velocidade e simplicidade de implementa\u00e7\u00e3o. Por\u00e9m, \u00e9 fundamental:</p> <ul> <li>Selecionar o piv\u00f4 de forma criteriosa (por exemplo, de forma aleat\u00f3ria) para evitar o pior caso.</li> <li>Conhecer bem as limita\u00e7\u00f5es e adapta\u00e7\u00f5es do algoritmo para diferentes problemas.</li> </ul>"},{"location":"quick_sort/#quiz-interativo","title":"Quiz Interativo","text":"<ol> <li> <p>Qual \u00e9 a complexidade do Quick Sort no melhor caso?</p> </li> <li> <p>O Quick Sort \u00e9 um algoritmo:</p> </li> <li> <p>Em qual ano foi desenvolvido o Quick Sort?</p> </li> </ol>"},{"location":"quick_sort/#recursos-graficos-na-web","title":"\ud83c\udf10 Recursos Gr\u00e1ficos na Web","text":"<ul> <li>Visualgo</li> <li>HackerEarth</li> </ul>"},{"location":"quick_sort/#dicas-para-o-leetcode","title":"\ud83c\udfc5 Dicas para o LeetCode","text":"<ol> <li>Compreenda bem o problema antes de come\u00e7ar a codificar.</li> <li>Pratique diferentes varia\u00e7\u00f5es do Quick Sort (piv\u00f4 fixo, aleat\u00f3rio, etc.).</li> <li>Teste casos extremos para assegurar efici\u00eancia.</li> <li>Pratique regularmente para aprimorar suas habilidades.</li> </ol>"},{"location":"quick_sort/#video-explicativo","title":"\ud83c\udfa5 V\u00eddeo Explicativo","text":"<p> Link do v\u00eddeo</p>"},{"location":"quick_sort/#referencias","title":"Refer\u00eancias","text":"<p>Esses detalhes adicionais enriquecem a documenta\u00e7\u00e3o do Quick Sort e ajudam a compreender melhor sua import\u00e2ncia na ci\u00eancia da computa\u00e7\u00e3o.</p> <p>Cita\u00e7\u00e3o:</p> <ol> <li>Wikipedia - Quick Sort</li> <li>Livro: Entendendo Algoritmos, Aditya Y. Bhargava.</li> <li>V\u00eddeo: Quicksort: Implementa\u00e7\u00e3o e Explica\u00e7\u00e3o</li> <li>DEV Community</li> <li>Blog Cyberini</li> <li>Khan Academy -</li> </ol>"}]}